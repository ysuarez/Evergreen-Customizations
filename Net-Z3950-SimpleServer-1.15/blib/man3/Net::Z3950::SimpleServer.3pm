.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SimpleServer 3pm"
.TH SimpleServer 3pm "2011-10-14" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Z3950::SimpleServer \- Simple Perl API for building Z39.50 servers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::Z3950::SimpleServer;
\&
\&  sub my_search_handler {
\&        my $args = shift;
\&
\&        my $set_id = $args\->{SETNAME};
\&        my @database_list = @{ $args\->{DATABASES} };
\&        my $query = $args\->{QUERY};
\&
\&        ## Perform the query on the specified set of databases
\&        ## and return the number of hits:
\&
\&        $args\->{HITS} = $hits;
\&  }
\&
\&  sub my_fetch_handler {        # Get a record for the user
\&        my $args = shift;
\&
\&        my $set_id = $args\->{SETNAME};
\&
\&        my $record = fetch_a_record($args\->{OFFSET});
\&
\&        $args\->{RECORD} = $record;
\&        if (number_of_hits() == $args\->{OFFSET}) {      ## Last record in set?
\&                $args\->{LAST} = 1;
\&        } else {
\&                $args\->{LAST} = 0;
\&        }
\&  }
\&
\&  ## Register custom event handlers:
\&  my $z = new Net::Z3950::SimpleServer(GHANDLE = $someObject,
\&                                       INIT   =>  \e&my_init_handler,
\&                                       CLOSE  =>  \e&my_close_handler,
\&                                       SEARCH =>  \e&my_search_handler,
\&                                       FETCH  =>  \e&my_fetch_handler);
\&
\&  ## Launch server:
\&  $z\->launch_server("ztest.pl", @ARGV);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The SimpleServer module is a tool for constructing Z39.50 \*(L"Information
Retrieval\*(R" servers in Perl. The module is easy to use, but it
does help to have an understanding of the Z39.50 query
structure and the construction of structured retrieval records.
.PP
Z39.50 is a network protocol for searching remote databases and
retrieving the results in the form of structured \*(L"records\*(R". It is widely
used in libraries around the world, as well as in the \s-1US\s0 Federal Government.
In addition, it is generally useful whenever you wish to integrate a number
of different database systems around a shared, abstract data model.
.PP
The model of the module is simple: It implements a \*(L"generic\*(R" Z39.50
server, which invokes callback functions supplied by you to search
for content in your database. You can use any tools available in
Perl to supply the content, including modules like \s-1DBI\s0 and
WWW::Search.
.PP
The server will take care of managing the network connections for
you, and it will spawn a new process (or thread, in some
environments) whenever a new connection is received.
.PP
The programmer can specify subroutines to take care of the following type
of events:
.PP
.Vb 6
\&  \- Initialize request
\&  \- Search request
\&  \- Present request
\&  \- Fetching of records
\&  \- Scan request (browsing) 
\&  \- Closing down connection
.Ve
.PP
Note that only the Search and Fetch handler functions are required.
The module can supply default responses to the other on its own.
.PP
After the launching of the server, all control is given away from
the Perl script to the server. The server calls the registered
subroutines to field incoming requests from Z39.50 clients.
.PP
A reference to an anonymous hash is passed to each handler. Some of
the entries of these hashes are to be considered input and others
output parameters.
.PP
The Perl programmer specifies the event handlers for the server by
means of the SimpleServer object constructor
.PP
.Vb 10
\&  my $z = new Net::Z3950::SimpleServer(
\&                        INIT    =>      \e&my_init_handler,
\&                        CLOSE   =>      \e&my_close_handler,
\&                        SEARCH  =>      \e&my_search_handler,
\&                        PRESENT =>      \e&my_present_handler,
\&                        SCAN    =>      \e&my_scan_handler,
\&                        FETCH   =>      \e&my_fetch_handler,
\&                        EXPLAIN =>      \e&my_explain_handler,
\&                        DELETE  =>      \e&my_delete_handler,
\&                        SORT    =>      \e&my_sort_handler);
.Ve
.PP
In addition, the arguments to the constructor may include \s-1GHANDLE\s0, a
global handle which is made available to each invocation of every
callback function.  This is typically a reference to either a hash or
an object.
.PP
If you want your SimpleServer to start a thread (threaded mode) to
handle each incoming Z39.50 request instead of forking a process
(forking mode), you need to register the handlers by symbol rather
than by code reference. Thus, in threaded mode, you will need to
register your handlers this way:
.PP
.Vb 5
\&  my $z = new Net::Z3950::SimpleServer(
\&                        INIT    =>      "my_package::my_init_handler",
\&                        CLOSE   =>      "my_package::my_close_handler",
\&                        ....
\&                        ....          );
.Ve
.PP
where my_package is the Perl package in which your handler is
located.
.PP
After the custom event handlers are declared, the server is launched
by means of the method
.PP
.Vb 1
\&  $z\->launch_server("MyServer.pl", @ARGV);
.Ve
.PP
Notice, the first argument should be the name of your server
script (for logging purposes), while the rest of the arguments
are documented in the \s-1YAZ\s0 toolkit manual: The section on
application invocation: <http://indexdata.com/yaz/doc/server.invocation.tkl>
.PP
In particular, you need to use the \-T switch to start your SimpleServer
in threaded mode.
.SS "Init handler"
.IX Subsection "Init handler"
The init handler is called whenever a Z39.50 client is attempting
to logon to the server. The exchange of parameters between the
server and the handler is carried out via an anonymous hash reached
by a reference, i.e.
.PP
.Vb 1
\&  $args = shift;
.Ve
.PP
The argument hash passed to the init handler has the form
.PP
.Vb 2
\&  $args = {
\&                                    ## Response parameters:
\&
\&             PEER_NAME =>  "",      ## Name or IP address of connecting client
\&             IMP_ID    =>  "",      ## Z39.50 Implementation ID
\&             IMP_NAME  =>  "",      ## Z39.50 Implementation name
\&             IMP_VER   =>  "",      ## Z39.50 Implementation version
\&             ERR_CODE  =>  0,       ## Error code, cnf. Z39.50 manual
\&             ERR_STR   =>  "",      ## Error string (additional info.)
\&             USER      =>  "xxx"    ## If Z39.50 authentication is used,
\&                                    ## this member contains user name
\&             PASS      =>  "yyy"    ## Under same conditions, this member
\&                                    ## contains the password in clear text
\&             GHANDLE   =>  $obj     ## Global handler specified at creation
\&             HANDLE    =>  undef    ## Handler of Perl data structure
\&          };
.Ve
.PP
The \s-1HANDLE\s0 member can be used to store any scalar value which will then
be provided as input to all subsequent calls (ie. for searching, record
retrieval, etc.). A common use of the handle is to store a reference to
a hash which may then be used to store session-specific parameters.
If you have any session-specific information (such as a list of
result sets or a handle to a back-end search engine of some sort),
it is always best to store them in a private session structure \-
rather than leaving them in global variables in your script.
.PP
The Implementation \s-1ID\s0, name and version are only really used by Z39.50
client developers to see what kind of server they're dealing with.
Filling these in is optional.
.PP
The \s-1ERR_CODE\s0 should be left at 0 (the default value) if you wish to
accept the connection. Any other value is interpreted as a failure
and the client will be shown the door, with the code and the
associated additional information, \s-1ERR_STR\s0 returned.
.SS "Search handler"
.IX Subsection "Search handler"
Similarly, the search handler is called with a reference to an anony\-
mous hash. The structure is the following:
.PP
.Vb 2
\&  $args = {
\&                                    ## Request parameters:
\&
\&             GHANDLE   =>  $obj     ## Global handler specified at creation
\&             HANDLE    =>  ref,     ## Your session reference.
\&             SETNAME   =>  "id",    ## ID of the result set
\&             REPL_SET  =>  0,       ## Replace set if already existing?
\&             DATABASES =>  ["xxx"], ## Reference to a list of data\-
\&                                    ## bases to search
\&             QUERY     =>  "query", ## The query expression
\&             RPN       =>  $obj,    ## Reference to a Net::Z3950::APDU::Query
\&
\&                                    ## Response parameters:
\&
\&             ERR_CODE  =>  0,       ## Error code (0=Successful search)
\&             ERR_STR   =>  "",      ## Error string
\&             HITS      =>  0        ## Number of matches
\&          };
.Ve
.PP
Note that a search which finds 0 hits is considered successful in
Z39.50 terms \- you should only set the \s-1ERR_CODE\s0 to a non-zero value
if there was a problem processing the request. The Z39.50 standard
provides a comprehensive list of standard diagnostic codes, and you
should use these whenever possible.
.PP
The \s-1QUERY\s0 is a tree-structure of terms combined by operators, the
terms being qualified by lists of attributes. The query is presented
to the search function in the Prefix Query Format (\s-1PQF\s0) which is
used in many applications based on the \s-1YAZ\s0 toolkit. The full grammar
is described in the \s-1YAZ\s0 manual.
.PP
The following are all examples of valid queries in the \s-1PQF\s0.
.PP
.Vb 1
\&        dylan
\&
\&        "bob dylan"
\&
\&        @or "dylan" "zimmerman"
\&
\&        @set Result\-1
\&
\&        @or @and bob dylan @set Result\-1
\&
\&        @and @attr 1=1 "bob dylan" @attr 1=4 "slow train coming"
\&
\&        @attrset @attr 4=1 @attr 1=4 "self portrait"
.Ve
.PP
You will need to write a recursive function or something similar to
parse incoming query expressions, and this is usually where a lot of
the work in writing a database-backend happens. Fortunately, you don't
need to support anymore functionality than you want to. For instance,
it is perfectly legal to not accept boolean operators, but you \s-1SHOULD\s0
try to return good error codes if you run into something you can't or
won't support.
.PP
A more convenient alternative to the \s-1QUERY\s0 member may be the \s-1RPN\s0
member, which is a reference to a Net::Z3950::APDU::Query object
representing the \s-1RPN\s0 query tree.  The structure of that object is
supposed to be self-documenting, but here's a brief summary of what
you get:
.IP "\(bu" 4
\&\f(CW\*(C`Net::Z3950::APDU::Query\*(C'\fR is a hash with two fields:
.Sp

.RS 4
.ie n .IP """attributeSet""" 4
.el .IP "\f(CWattributeSet\fR" 4
.IX Item "attributeSet"
Optional.  If present, it is a reference to a
\&\f(CW\*(C`Net::Z3950::APDU::OID\*(C'\fR.  This is a string of dot-separated integers
representing the \s-1OID\s0 of the query's top-level attribute set.
.ie n .IP """query""" 4
.el .IP "\f(CWquery\fR" 4
.IX Item "query"
Mandatory: a reference to the \s-1RPN\s0 tree itself.
.RE
.RS 4
.RE
.IP "\(bu" 4
Each node of the tree is an object of one of the following types:
.Sp

.RS 4
.ie n .IP """Net::Z3950::RPN::And""" 4
.el .IP "\f(CWNet::Z3950::RPN::And\fR" 4
.IX Item "Net::Z3950::RPN::And"
.PD 0
.ie n .IP """Net::Z3950::RPN::Or""" 4
.el .IP "\f(CWNet::Z3950::RPN::Or\fR" 4
.IX Item "Net::Z3950::RPN::Or"
.ie n .IP """Net::Z3950::RPN::AndNot""" 4
.el .IP "\f(CWNet::Z3950::RPN::AndNot\fR" 4
.IX Item "Net::Z3950::RPN::AndNot"
.PD
These three classes are all arrays of two elements, each of which is a
node of one of the above types.
.ie n .IP """Net::Z3950::RPN::Term""" 4
.el .IP "\f(CWNet::Z3950::RPN::Term\fR" 4
.IX Item "Net::Z3950::RPN::Term"
See below for details.
.ie n .IP """Net::Z3950::RPN::RSID""" 4
.el .IP "\f(CWNet::Z3950::RPN::RSID\fR" 4
.IX Item "Net::Z3950::RPN::RSID"
A reference to a result-set \s-1ID\s0 indicating a previous search.  The \s-1ID\s0
of the result-set is in the \f(CW\*(C`id\*(C'\fR element.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`Net::Z3950::RPN::Term\*(C'\fR is a hash with two fields:
.Sp

.RS 4
.ie n .IP """term""" 4
.el .IP "\f(CWterm\fR" 4
.IX Item "term"
A string containing the search term itself.
.ie n .IP """attributes""" 4
.el .IP "\f(CWattributes\fR" 4
.IX Item "attributes"
A reference to a \f(CW\*(C`Net::Z3950::RPN::Attributes\*(C'\fR object.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\f(CW\*(C`Net::Z3950::RPN::Attributes\*(C'\fR is an array of references to
\&\f(CW\*(C`Net::Z3950::RPN::Attribute\*(C'\fR objects.  (Note the plural/singular
distinction.)
.IP "\(bu" 4
\&\f(CW\*(C`Net::Z3950::RPN::Attribute\*(C'\fR is a hash with three elements:
.Sp

.RS 4
.ie n .IP """attributeSet""" 4
.el .IP "\f(CWattributeSet\fR" 4
.IX Item "attributeSet"
Optional.  If present, it is dot-separated \s-1OID\s0 string, as above.
.ie n .IP """attributeType""" 4
.el .IP "\f(CWattributeType\fR" 4
.IX Item "attributeType"
An integer indicating the type of the attribute \- for example, under
the \s-1BIB\-1\s0 attribute set, type 1 indicates a ``use'' attribute, type 2
a ``relation'' attribute, etc.
.ie n .IP """attributeValue""" 4
.el .IP "\f(CWattributeValue\fR" 4
.IX Item "attributeValue"
An integer or string indicating the value of the attribute \- for example, under
\&\s-1BIB\-1\s0, if the attribute type is 1, then value 4 indicates a title
search and 7 indicates an \s-1ISBN\s0 search; but if the attribute type is
2, then value 4 indicates a ``greater than or equal'' search, and 102
indicates a relevance match.
.RE
.RS 4
.RE
.PP
All of these classes except \f(CW\*(C`Attributes\*(C'\fR and \f(CW\*(C`Attribute\*(C'\fR are
subclasses of the abstract class \f(CW\*(C`Net::Z3950::RPN::Node\*(C'\fR.  That class
has a single method, \f(CW\*(C`toPQF()\*(C'\fR, which may be used to turn an \s-1RPN\s0
tree, or part of one, back into a textual prefix query.
.PP
Note that, apart to \f(CW\*(C`toPQF()\*(C'\fR, none of these classes have any methods at
all: the blessing into classes is largely just a documentation thing
so that, for example, if you do
.PP
.Vb 1
\&        { use Data::Dumper; print Dumper($args\->{RPN}) }
.Ve
.PP
you get something fairly human-readable.  But of course, the type
distinction between the three different kinds of boolean node is
important.
.PP
By adding your own methods to these classes (building what I call
``augmented classes''), you can easily build code that walks the tree
of the incoming \s-1RPN\s0.  Take a look at \f(CW\*(C`samples/render\-search.pl\*(C'\fR for a
sample implementation of such an augmented classes technique.
.SS "Present handler"
.IX Subsection "Present handler"
The presence of a present handler in a SimpleServer front-end is optional.
Each time a client wishes to retrieve records, the present service is
called. The present service allows the origin to request a certain number
of records retrieved from a given result set.
When the present handler is called, the front-end server should prepare a
result set for fetching. In practice, this means to get access to the
data from the backend database and store the data in a temporary fashion
for fast and efficient fetching. The present handler does *not* fetch
anything. This task is taken care of by the fetch handler, which will be
called the correct number of times by the \s-1YAZ\s0 library. More about this
below.
If no present handler is implemented in the front-end, the \s-1YAZ\s0 toolkit
will take care of a minimum of preparations itself. This default present
handler is sufficient in many situations, where only a small amount of
records are expected to be retrieved. If on the other hand, large result
sets are likely to occur, the implementation of a reasonable present
handler can gain performance significantly.
.PP
The information exchanged between client and present handle is:
.PP
.Vb 2
\&  $args = {
\&                                    ## Client/server request:
\&
\&             GHANDLE   =>  $obj     ## Global handler specified at creation
\&             HANDLE    =>  ref,     ## Reference to datastructure
\&             SETNAME   =>  "id",    ## Result set ID
\&             START     =>  xxx,     ## Start position
\&             COMP      =>  "",      ## Desired record composition
\&             NUMBER    =>  yyy,     ## Number of requested records
\&
\&
\&                                    ## Response parameters:
\&
\&             HITS      =>  zzz,     ## Number of returned records
\&             ERR_CODE  =>  0,       ## Error code
\&             ERR_STR   =>  ""       ## Error message
\&          };
.Ve
.SS "Fetch handler"
.IX Subsection "Fetch handler"
The fetch handler is asked to retrieve a \s-1SINGLE\s0 record from a given
result set (the front-end server will automatically call the fetch
handler as many times as required).
.PP
The parameters exchanged between the server and the fetch handler are
.PP
.Vb 2
\&  $args = {
\&                                    ## Client/server request:
\&
\&             GHANDLE   =>  $obj     ## Global handler specified at creation
\&             HANDLE    =>  ref      ## Reference to data structure
\&             SETNAME   =>  "id"     ## ID of the requested result set
\&             OFFSET    =>  nnn      ## Record offset number
\&             REQ_FORM  =>  "n.m.k.l"## Client requested format OID
\&             COMP      =>  "xyz"    ## Formatting instructions
\&             SCHEMA    =>  "abc"    ## Requested schema, if any
\&
\&                                    ## Handler response:
\&
\&             RECORD    =>  ""       ## Record string
\&             BASENAME  =>  ""       ## Origin of returned record
\&             LAST      =>  0        ## Last record in set?
\&             ERR_CODE  =>  0        ## Error code
\&             ERR_STR   =>  ""       ## Error string
\&             SUR_FLAG  =>  0        ## Surrogate diagnostic flag
\&             REP_FORM  =>  "n.m.k.l"## Provided format OID
\&             SCHEMA    =>  "abc"    ## Provided schema, if any
\&          };
.Ve
.PP
The \s-1REP_FORM\s0 value has by default the \s-1REQ_FORM\s0 value but can be set to
something different if the handler desires. The \s-1BASENAME\s0 value should
contain the name of the database from where the returned record originates.
The \s-1ERR_CODE\s0 and \s-1ERR_STR\s0 works the same way they do in the search
handler. If there is an error condition, the \s-1SUR_FLAG\s0 is used to
indicate whether the error condition pertains to the record currently
being retrieved, or whether it pertains to the operation as a whole
(eg. the client has specified a result set which does not exist.)
.PP
If you need to return \s-1USMARC\s0 records, you might want to have a look at
the \s-1MARC\s0 module on \s-1CPAN\s0, if you don't already have a way of generating
these.
.PP
\&\s-1NOTE:\s0 The record offset is 1\-indexed \- 1 is the offset of the first
record in the set.
.SS "Scan handler"
.IX Subsection "Scan handler"
A full featured Z39.50 server should support scan (or in some literature
browse). The client specifies a starting term of the scan, and the server
should return an ordered list of specified length consisting of terms
actually occurring in the data base. Each of these terms should be close
to or equal to the term originally specified. The quality of scan compared
to simple search is a guarantee of hits. It is simply like browsing through
an index of a book, you always find something! The parameters exchanged are
.PP
.Vb 2
\&  $args = {
\&                                                ## Client request
\&
\&                GHANDLE         => $obj,        ## Global handler specified at creation
\&                HANDLE          => $ref,        ## Reference to data structure
\&                DATABASES       => ["xxx"],     ## Reference to a list of data\-
\&                                                ## bases to search
\&                TERM            => \*(Aqstart\*(Aq,     ## The start term
\&                RPN             =>  $obj,       ## Reference to a Net::Z3950::RPN::Term
\&
\&                NUMBER          => xx,          ## Number of requested terms
\&                POS             => yy,          ## Position of starting point
\&                                                ## within returned list
\&                STEP            => 0,           ## Step size
\&
\&                                                ## Server response
\&
\&                ERR_CODE        => 0,           ## Error code
\&                ERR_STR         => \*(Aq\*(Aq,          ## Diagnostic message
\&                NUMBER          => zz,          ## Number of returned terms
\&                STATUS          => $status,     ## ScanSuccess/ScanFailure
\&                ENTRIES         => $entries     ## Referenced list of terms
\&        };
.Ve
.PP
where the term list is returned by reference in the scalar \f(CW$entries\fR, which
should point at a data structure of this kind,
.PP
.Vb 3
\&  my $entries = [
\&                        {       TERM            => \*(Aqenergy\*(Aq,
\&                                OCCURRENCE      => 5            },
\&
\&                        {       TERM            => \*(Aqenergy density\*(Aq,
\&                                OCCURRENCE      => 6,           },
\&
\&                        {       TERM            => \*(Aqenergy flow\*(Aq,
\&                                OCCURRENCE      => 3            },
\&
\&                                ...
\&
\&                                ...
\&        ];
.Ve
.PP
The \f(CW$status\fR flag is only meaningful after a successful scan, and
should be assigned one of two values:
.PP
.Vb 2
\&  Net::Z3950::SimpleServer::ScanSuccess  Full success (default)
\&  Net::Z3950::SimpleServer::ScanPartial  Fewer terms returned than requested
.Ve
.PP
The \s-1STEP\s0 member contains the requested number of entries in the term-list
between two adjacent entries in the response.
.PP
A better alternative to the \s-1TERM\s0 member is the the \s-1RPN\s0
member, which is a reference to a Net::Z3950::RPN::Term object
representing the scan clause.  The structure of that object is the
same as for Term objects included as part of the \s-1RPN\s0 tree passed to
search handlers.  This is more useful than the simple \s-1TERM\s0 because it
includes attributes (e.g. access points associated with the term),
which are discarded by the \s-1TERM\s0 element.
.SS "Close handler"
.IX Subsection "Close handler"
The argument hash received by the close handler has two elements only:
.PP
.Vb 2
\&  $args = {
\&                                    ## Server provides:
\&
\&             GHANDLE   =>  $obj     ## Global handler specified at creation
\&             HANDLE    =>  ref      ## Reference to data structure
\&          };
.Ve
.PP
What ever data structure the \s-1HANDLE\s0 value points at goes out of scope
after this call. If you need to close down a connection to your server
or something similar, this is the place to do it.
.SS "Delete handler"
.IX Subsection "Delete handler"
The argument hash received by the delete handler has the following elements:
.PP
.Vb 5
\&  $args = {
\&                                    ## Client request:
\&             GHANDLE   =>  $obj,    ## Global handler specified at creation
\&             HANDLE    =>  ref,     ## Reference to data structure
\&             SETNAME   =>  "id",    ## Result set ID
\&
\&                                    ## Server response:
\&             STATUS    => 0         ## Deletion status
\&          };
.Ve
.PP
The \s-1SETNAME\s0 element of the argument hash may or may not be defined.
If it is, then \s-1SETNAME\s0 is the name of a result set to be deleted; if
not, then all result-sets associated with the current session should
be deleted.  In either case, the callback function should report on
success or failure by setting the \s-1STATUS\s0 element either to zero, on
success, or to an integer from 1 to 10, to indicate one of the ten
possible failure codes described in section 3.2.4.1.4 of the Z39.50
standard \*(-- see 
http://www.loc.gov/z3950/agency/markup/05.html#Delete\-list\-statuses1
.SS "Sort handler"
.IX Subsection "Sort handler"
The argument hash received by the sort handler has the following elements:
.PP
.Vb 7
\&        $args = {
\&                                        ## Client request:
\&                GHANDLE => $obj,        ## Global handler specified at creation
\&                HANDLE => ref,          ## Reference to data structure
\&                INPUT => [ a, b ... ],  ## Names of result\-sets to sort
\&                OUTPUT => "name",       ## Name of result\-set to sort into
\&                SEQUENCE                ## Sort specification: see below
\&
\&                                        ## Server response:
\&                STATUS => 0,            ## Success, Partial or Failure
\&                ERR_CODE => 0,          ## Error code
\&                ERR_STR => \*(Aq\*(Aq,          ## Diagnostic message
\&
\&        };
.Ve
.PP
The \s-1SEQUENCE\s0 element is a reference to an array, each element of which
is a hash representing a sort key.  Each hash contains the following
elements:
.IP "\s-1RELATION\s0" 4
.IX Item "RELATION"
0 for an ascending sort, 1 for descending, 3 for ascending by
frequency, or 4 for descending by frequency.
.IP "\s-1CASE\s0" 4
.IX Item "CASE"
0 for a case-sensitive sort, 1 for case-insensitive
.IP "\s-1MISSING\s0" 4
.IX Item "MISSING"
How to respond if one or more records in the set to be sorted are
missing the fields indicated in the sort specification.  1 to abort
the sort, 2 to use a \*(L"null value\*(R", 3 if a value is provided to use in
place of the missing data (although in the latter case, the actual
value to use is currently not made available, so this is useless).
.PP
And one or other of the following:
.IP "\s-1SORTFIELD\s0" 4
.IX Item "SORTFIELD"
A string indicating the field to be sorted, which the server may
interpret as it sees fit (presumably by an out-of-band agreement with
the client).
.IP "\s-1ELEMENTSPEC_TYPE\s0 and \s-1ELEMENTSPEC_VALUE\s0" 4
.IX Item "ELEMENTSPEC_TYPE and ELEMENTSPEC_VALUE"
I have no idea what this is.
.IP "\s-1ATTRSET\s0 and \s-1SORT_ATTR\s0" 4
.IX Item "ATTRSET and SORT_ATTR"
\&\s-1ATTRSET\s0 is the attribute set from which the attributes are taken, and
\&\s-1SORT_ATTR\s0 is a reference to an array containing the attributes
themselves.  Each attribute is represented by (are you following this
carefully?) yet another hash, this one containing the elements
\&\s-1ATTR_TYPE\s0 and \s-1ATTR_VALUE:\s0 for example, type=1 and value=4 in the \s-1BIB\-1\s0
attribute set would indicate access-point 4 which is title, so that a
sort of title is requested.
.PP
Precisely why all of the above is so is not clear, but goes some way
to explain why, in the Z39.50 world, the developers of the standard
are not so much worshiped as blamed.
.PP
The backend function should set \s-1STATUS\s0 to 0 on success, 1 for \*(L"partial
success\*(R" (don't ask) or 2 on failure, in which case \s-1ERR_CODE\s0 and
\&\s-1ERR_STR\s0 should be set.
.SS "Support for \s-1SRU\s0 and \s-1SRW\s0"
.IX Subsection "Support for SRU and SRW"
Since release 1.0, SimpleServer includes support for serving the \s-1SRU\s0
and \s-1SRW\s0 protocols as well as Z39.50.  These ``web\-friendly'' protocols
enable similar functionality to that of Z39.50, but by means of rich
URLs in the case of \s-1SRU\s0, and a SOAP-based web-service in the case of
\&\s-1SRW\s0.  These protocols are described at
http://www.loc.gov/sru
.PP
In order to serve these protocols from a SimpleServer-based
application, it is necessary to launch the application with a \s-1YAZ\s0
Generic Frontend Server (\s-1GFS\s0) configuration file, which can be
specified using the command-line argument \f(CW\*(C`\-f\*(C'\fR \fIfilename\fR.  A
minimal configuration file looks like this:
.PP
.Vb 5
\&  <yazgfs>
\&    <server>
\&      <cql2rpn>pqf.properties</cql2rpn>
\&    </server>
\&  </yazgfs>
.Ve
.PP
This file specifies only that \f(CW\*(C`pqf.properties\*(C'\fR should be used to
translate the \s-1CQL\s0 queries of \s-1SRU\s0 and \s-1SRW\s0 into corresponding Z39.50
Type\-1 queries.  For more information about \s-1YAZ\s0 \s-1GFS\s0 configuration,
including how to specify an Explain record, see the \fIVirtual Hosts\fR
section of the \s-1YAZ\s0 manual at
http://indexdata.com/yaz/doc/server.vhosts.tkl
.PP
The mapping of \s-1CQL\s0 queries into Z39.50 Type\-1 queries is specified by
a file that indicates which \s-1BIB\-1\s0 attributes should be generated for
each \s-1CQL\s0 index, relation, modifiers, etc.  A typical section of this
file looks like this:
.PP
.Vb 5
\&  index.dc.title                        = 1=4
\&  index.dc.subject                      = 1=21
\&  index.dc.creator                      = 1=1003
\&  relation.<                            = 2=1
\&  relation.le                           = 2=2
.Ve
.PP
This file specifies the \s-1BIB\-1\s0 access points (type=1) for the Dublin
Core indexes \f(CW\*(C`title\*(C'\fR, \f(CW\*(C`subject\*(C'\fR and \f(CW\*(C`creator\*(C'\fR, and the \s-1BIB\-1\s0
relations (type=2) corresponding to the \s-1CQL\s0 relations \f(CW\*(C`<\*(C'\fR and
\&\f(CW\*(C`<=\*(C'\fR.  For more information about the format of this file, see
the \fI\s-1CQL\s0\fR section of the \s-1YAZ\s0 manual at
http://indexdata.com/yaz/doc/tools.tkl#tools.cql
.PP
The \s-1YAZ\s0 distribution include a sample CQL-to-PQF mapping configuration
file called \f(CW\*(C`pqf.properties\*(C'\fR; this is sufficient for many
applications, and a good base to work from for most others.
.PP
If a SimpleServer-based application is run without this SRU-specific
configuration, it can still serve \s-1SRU\s0; however, \s-1CQL\s0 queries will not
be translated, but passed straight through to the search-handler
function, as the \f(CW\*(C`CQL\*(C'\fR member of the parameters hash.  It is then the
responsibility of the back-end application to parse and handle the \s-1CQL\s0
query, which is most easily done using Ed Summers' fine \f(CW\*(C`CQL::Parser\*(C'\fR
module, available from \s-1CPAN\s0 at
http://search.cpan.org/~esummers/CQL\-Parser/
.SH "AUTHORS"
.IX Header "AUTHORS"
Anders So\*/nderberg (sondberg@indexdata.dk),
Sebastian Hammer (quinn@indexdata.dk),
Mike Taylor (indexdata.com).
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
Copyright (C) 2000\-2011 by Index Data.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Any Perl module which is useful for accessing the data source of your
choice.
